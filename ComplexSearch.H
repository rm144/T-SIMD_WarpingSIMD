// ===========================================================================
// 
// ComplexSearch.H --
// template for complex (double, partial etc.) search
// 
// This source code file is part of the following software:
// 
//    - the low-level C++ template SIMD library
//    - the SIMD implementation of the MinWarping and the 2D-Warping methods 
//      for local visual homing.
// 
// The software is provided based on the accompanying license agreement
// in the file LICENSE or LICENSE.doc. The software is provided "as is"
// without any warranty by the licensor and without any liability of the
// licensor, and the software may not be distributed by the licensee; see
// the license agreement for details.
// 
// (C) Ralf MÃ¶ller
//     Computer Engineering
//     Faculty of Technology
//     Bielefeld University
//     www.ti.uni-bielefeld.de
// 
// ===========================================================================

#ifndef _COMPLEX_SEARCH_H_
#define _COMPLEX_SEARCH_H_

#include <cmath>
#include "SIMDException.H"
#include "WarpingParameter.H"
#include "WarpingSPS.H"
#include "MinWarpingMatch.H"
#include "MinWarpingSearchRange.H"
#include "SIMDImage.H"

namespace ns_simd {

  class ComplexSearchSelector
  {
  public:
    enum {SPS_ORIG, SPS_INV, NUM_SPS};
    enum {MATCH_1, MATCH_2, MATCH_2_INV, MATCH_RES, 
	  MATCH_FINE_1, MATCH_FINE_2, MATCH_FINE_2_INV, MATCH_FINE_RES, 
	  NUM_MATCH};
  };

  // ComplexSearch: template class with template parameter
  // SearchTemplateClass (e.g. MinWarpingTemplate or WarpingTemplate);
  // allows to define full, partial, fine search as either single or
  // double search independent of the SearchTemplateClass; search
  // functions are also templates with template template parameters
  // FullSearchClass or PartialSearcherClass

  template <typename SPSType, typename MatchType, typename CompassType,
	    int SIMD_WIDTH, int SIMD_ALIGN,
	    class SearchTemplateClass>
  class ComplexSearch : public ComplexSearchSelector
  {

  protected:

    // spsWasInverted indicates whether a previous search was a double
    // search where an inverted scale-plane stack was computed; is
    // needed to decide whether fine search can be done as double
    // search as well
    bool spsWasInverted;

    // invertAndAverage inverts match array MATCH_2 to MATCH_2_INV,
    // averages with MATCH_1, and returns MATCH_RES
    inline MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    invertAndAverage()
    {
      // average
      matchArray[MATCH_2_INV]->invertFrom(*(matchArray[MATCH_2]));
      matchArray[MATCH_RES]->averageOf(*(matchArray[MATCH_1]),
				       *(matchArray[MATCH_2_INV]));
      return (matchResPtr = matchArray[MATCH_RES]);
    }

  public:
    
    const WarpingParameter<SPSType,SIMD_WIDTH> &param;
    WarpingSPS<SPSType,SIMD_WIDTH,SIMD_ALIGN> **spsArray;
    SearchTemplateClass *searchTemplate;
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN> **matchArray, *matchResPtr;
  
    // constructor receives references or pointers to data structures
    // such that these can be shared by multiple ComplexSearch
    // instances; searchTemplate is deleted in the destructor such
    // that a pointer can be generated by new directly in the
    // constructor call
    ComplexSearch(const WarpingParameter<SPSType,SIMD_WIDTH> &param,
		  WarpingSPS<SPSType,SIMD_WIDTH,SIMD_ALIGN> **spsArray,
		  SearchTemplateClass *searchTemplate,
		  MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN> **matchArray)
      : spsWasInverted(false),
	param(param), spsArray(spsArray), 
	searchTemplate(searchTemplate), matchArray(matchArray),
	matchResPtr(0)
    {
    }

    ~ComplexSearch()
    {
      delete searchTemplate;
    }

    // =========================================================================
    // search result
    // =========================================================================
  
    // full search for the best match in the match array pointed to by
    // internal variable matchResPtr
    void bestMatchFull(int &iAlphaMin, double &alphaMin, 
		       int &iPsiMin, double &psiMin, 
		       double &dMin)
    {
      MatchType _dMin;
      if (!matchResPtr)
	throw SIMDException("WarpingCompound::bestMatchFull",
			    "no result available");
      matchResPtr->bestMatchFull(iAlphaMin, iPsiMin, _dMin);
      dMin = double(_dMin);
      psiMin = param.psiVec[iPsiMin];
      alphaMin = param.alphaVec[iAlphaMin];
    }

    // invert solution given by indices of alpha and psi
    void invertSolution(int iAlphaMin, int iPsiMin,
			int &iAlphaMinInv, int &iPsiMinInv)
    {   
      if (!matchResPtr)
	throw SIMDException("WarpingCompound::invertSolution",
			    "no result available");
      matchResPtr->invertSolution(iAlphaMin, iPsiMin, iAlphaMinInv, iPsiMinInv);
    }

    // =========================================================================
    // full and partial search (using fullSearcher and partialSearcher)
    // =========================================================================

    template<template <typename,typename,int,int> class FullSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    full(FullSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN> 
	 &searchAlgorithm, 
	 bool doubleSearch)
    {
      spsWasInverted = doubleSearch;
      // first run
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_ORIG]),
			     *(matchArray[MATCH_1]));
      if (!doubleSearch) return (matchResPtr = matchArray[MATCH_1]);
      // second run
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]),
			     *(matchArray[MATCH_2]));
      return invertAndAverage();
    }
    
    template<template <typename,typename,int,int> class PartialSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    partial(PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
	    &searchAlgorithm,
	    bool doubleSearch,
	    double alphaEst, double alphaRadius,
	    double psiEst, double psiRadius)
    {
      MinWarpingSearchRange<SPSType,SIMD_WIDTH,SIMD_ALIGN> 
	range(param.nAlpha, param.nPsi);
      spsWasInverted = doubleSearch;
      // first run
      range.setPartialRange(alphaEst, alphaRadius, psiEst, psiRadius);
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_ORIG]), range,
			     *(matchArray[MATCH_1]));
      if (!doubleSearch) 
	return (matchResPtr = matchArray[MATCH_1]);
      // second run
      // we have to invert the search range centers as well for second
      // computation
      double psiEstInv = 2.0 * M_PI - psiEst;
      double alphaEstInv = M_PI  + alphaEst - psiEst;
      range.setPartialRange(alphaEstInv, alphaRadius, psiEstInv, psiRadius);
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]), range,
			     *(matchArray[MATCH_2]));
      return invertAndAverage();
    }
    
    // for tests only: uses partial searcher but performs a full-range search
    template<template <typename,typename,int,int> class PartialSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    partialFull(PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
		&searchAlgorithm,
		bool doubleSearch)
    {
      MinWarpingSearchRange<SPSType,SIMD_WIDTH,SIMD_ALIGN> 
	range(param.nAlpha, param.nPsi);
      spsWasInverted = doubleSearch;
      range.setFullRange();
      // first run
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_ORIG]), range,
			     *(matchArray[MATCH_1]));
      if (!doubleSearch) 
	return (matchResPtr = matchArray[MATCH_1]);
      // second run
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]), range,
			     *(matchArray[MATCH_2]));
      return invertAndAverage();
    }

    // TODO: - compass acceleration: it should be possible to invert the
    // TODO:   compass directly, but the problem is that the inversion
    // TODO:   operation in WarpingSPS::invertFrom operates on the pixel
    // TODO:   index whereas the compass array is indexed by the param
    // TODO:   index; at the moment we therefore invert the SPS and
    // TODO:   compute the compass again
    template<template <typename,typename,int,int> class PartialSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    compassAcceleration
    (PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
     &searchAlgorithm,
     bool doubleSearch,
     double psiFraction)
    {
      SIMDImage<CompassType,SIMD_WIDTH,SIMD_ALIGN> compass;
      MinWarpingSearchRange<SPSType,SIMD_WIDTH,SIMD_ALIGN> 
	range(param.nAlpha, param.nPsi);
      spsWasInverted = doubleSearch;
      // first run
      spsArray[SPS_ORIG]->compassEstimate(compass);
      range.setFullCompassRange(psiFraction, compass);
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_ORIG]), range,
			     *(matchArray[MATCH_1]));
      if (!doubleSearch) 
	return (matchResPtr = matchArray[MATCH_1]);
      // second run
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      spsArray[SPS_INV]->compassEstimate(compass);
      range.setFullCompassRange(psiFraction, compass);
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]), range,
			     *(matchArray[MATCH_2]));
      return invertAndAverage();
    }
    
    template<template <typename,typename,int,int> class PartialSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    quantilCompassAcceleration
    (PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
     &searchAlgorithm,
     bool doubleSearch,
     double psiFraction,
     double quantilFraction)
    {
      SIMDImage<SPSType,SIMD_WIDTH,SIMD_ALIGN> compass;
      MinWarpingSearchRange<SPSType,SIMD_WIDTH,SIMD_ALIGN> 
	range(param.nAlpha, param.nPsi);
      spsWasInverted = doubleSearch;
      // first run
      spsArray[SPS_ORIG]->quantilCompassEstimate(compass, quantilFraction);
      range.setFullCompassRange(psiFraction, compass);
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_ORIG]), range,
			     *(matchArray[MATCH_1]));
      if (!doubleSearch) 
	return (matchResPtr = matchArray[MATCH_1]);
      // second run
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      spsArray[SPS_INV]->quantilCompassEstimate(compass, quantilFraction);
      range.setFullCompassRange(psiFraction, compass);
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]), range,
			     *(matchArray[MATCH_2]));
      return invertAndAverage();
    }

    // for tests: only inverse search
    template<template <typename,typename,int,int> class FullSearcherClass>
    MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN>*
    fullInverse
    (FullSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
     &searchAlgorithm)
    {
      spsWasInverted = true;
      spsArray[SPS_INV]->invertFrom(*(spsArray[SPS_ORIG]));
      searchAlgorithm.search(*searchTemplate,
			     *(spsArray[SPS_INV]),
			     *(matchArray[MATCH_2]));
      matchArray[MATCH_2_INV]->invertFrom(*(matchArray[MATCH_2]));
      return (matchResPtr = matchArray[MATCH_2_INV]);
    }

    // fine search
    template<template <typename,typename,int,int> class PartialSearcherClass>
    void 
    fine
    (PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
     &searchAlgorithm,
     bool doubleSearch, int iAlpha, int iPsi,
     int &jAlphaOffBest, double &alphaBest, 
     int &jPsiOffBest, double &psiBest,
     double &matchBest,
     SIMDImage<MatchType,1,1> &fineMatch,
     bool surround = false)
    {
      if (!matchResPtr)
	throw SIMDException("WarpingCompound::fineSearch",
			    "no previous search");
      if (doubleSearch && !spsWasInverted)
	throw SIMDException("WarpingCompound::fineSearch",
			    "double fine search requires inverted sps");
      // pointer to array which holds the result of the fine search
      MinWarpingMatch<MatchType,SIMD_WIDTH,SIMD_ALIGN> *matchFineRes;	
      // search range
      MinWarpingSearchRange<SPSType,SIMD_WIDTH,SIMD_ALIGN> 
	range(param.nAlpha, param.nPsi);
      // surround = false: search entire range between solutions
      // surround = true: only search surrounding of this solution
      const int alphaRange 
	= surround ? param.stepAlpha / 2 : param.stepAlpha - 1;
      const int psiRange 
	= surround ? param.stepPsi / 2 : param.stepPsi - 1;
      // result image
      fineMatch.resize(2 * alphaRange + 1, 2 * psiRange + 1);
      // minimum search
      MatchType _matchBest = SIMDTypeInfo<MatchType>::max();
      jAlphaOffBest = jPsiOffBest = 0;
      // for (int m = MATCH_FINE_1; m < NUM_MATCH; m++)
      //   matchArray[m]->fillInvalid();
      // go through all offset pairs (including 0,0)
      for (int jPsiOff  = -psiRange; jPsiOff <= psiRange; jPsiOff++) {
	for (int jAlphaOff = -alphaRange; jAlphaOff<=alphaRange; jAlphaOff++) {
	  // first search
	  range.setSingleRange(iAlpha, iPsi);
	  searchAlgorithm.search(*searchTemplate,
				 *(spsArray[SPS_ORIG]), range,
				 *(matchArray[MATCH_FINE_1]),
				 jAlphaOff, jPsiOff);
	  if (!doubleSearch)
	    // single search
	    matchFineRes = matchArray[MATCH_FINE_1];
	  else {
	    // double search
	    int iAlphaInv, iPsiInv;
	    matchArray[MATCH_FINE_1]->invertSolution(iAlpha, iPsi,
						     iAlphaInv, iPsiInv);
	    range.setSingleRange(iAlphaInv, iPsiInv);
	    int jPsiOffInv = -jPsiOff, jAlphaOffInv = jAlphaOff - jPsiOff;
	    searchAlgorithm.search(*searchTemplate,
				   *(spsArray[SPS_INV]), range,
				   *(matchArray[MATCH_FINE_2]),
				   jAlphaOffInv, jPsiOffInv);
	    // average
#if 1
	    // faster version: only for single iPsi
	    matchArray[MATCH_FINE_2_INV]->invertSinglePsiFrom
	      (*(matchArray[MATCH_FINE_2]), iPsi);
	    matchArray[MATCH_FINE_RES]->averageSinglePsiOf
	      (*(matchArray[MATCH_FINE_1]),
	       *(matchArray[MATCH_FINE_2_INV]), iPsi);
#else
	    // slower version
	    matchArray[MATCH_FINE_2_INV]->invertFrom
	      (*(matchArray[MATCH_FINE_2]));
	    matchArray[MATCH_FINE_RES]->averageOf
	      (*(matchArray[MATCH_FINE_1]),
	       *(matchArray[MATCH_FINE_2_INV]));
#endif
	    matchFineRes = matchArray[MATCH_FINE_RES];
	  }
	  MatchType _dMin = (*matchFineRes)[iPsi][iAlpha];
	  fineMatch[jPsiOff + psiRange][jAlphaOff + alphaRange] = _dMin;
	  // should never happen:
	  // 17. Feb 16 (rm) (it actually *can* happen if postScale is
	  // too large, probably because sums run into saturation and
	  // invalid is the same as the saturated value)
	  assert(_dMin != matchFineRes->invalid);
	  if (_dMin < _matchBest) {
	    _matchBest = _dMin;
	    jAlphaOffBest = jAlphaOff;
	    jPsiOffBest = jPsiOff;
	  }
	}
      }
      matchBest = double(_matchBest);
      // angles are not in [0, 2*pi)
      alphaBest = param.alphaVec[iAlpha] + jAlphaOffBest * param.dTheta;
      psiBest = param.psiVec[iPsi] + jPsiOffBest * param.dTheta;
    }
  
    // all combined
    // specifically useful for tests with different parameter
    // combinations, otherwise one could better pick a specific search
    // mode from the functions above
    template<template <typename,typename,int,int> class FullSearcherClass,
	     template <typename,typename,int,int> class PartialSearcherClass>
    void
    search(FullSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
	   &fullSearchAlgorithm,
	   PartialSearcherClass<SPSType,MatchType,SIMD_WIDTH,SIMD_ALIGN>
	   &partialSearchAlgorithm,
	   double alphaEst, double psiEst,
	   int compassAccelerationMode,
	   double psiFraction,
	   double quantilCompassFraction,
	   int partialSearch,
	   double alphaRad, double psiRad,
	   int partialFullSearch,
	   int doubleSearch,
	   int fineSearch,
	   int doubleSearchFine,
	   int fineSearchSurround,
	   double &alphaMin, double &psiMin, double &dMin,
	   int &iAlphaMin, int &iPsiMin,
	   int &iAlphaMinInv, int &iPsiMinInv,
	   int &jAlphaOff, int &jPsiOff,
	   SIMDImage<MatchType,1,1> &fineMatch)
    {
	if (compassAccelerationMode == 1)
	  // with compass acceleration (psi), sum
	  compassAcceleration(partialSearchAlgorithm, doubleSearch, 
			      psiFraction);
	else if (compassAccelerationMode == 2)
	  // with compass acceleration (psi), quantil
	  quantilCompassAcceleration(partialSearchAlgorithm, doubleSearch, 
				     psiFraction, quantilCompassFraction);
	else if (partialSearch)
	  // partial search
	  partial(partialSearchAlgorithm, doubleSearch,
		  alphaEst, alphaRad, psiEst, psiRad);
	else if (partialFullSearch)
	  // full search, but with partial searcher (for tests only)
	  partialFull(partialSearchAlgorithm, doubleSearch);
	else
	  // full search
	  full(fullSearchAlgorithm, doubleSearch);
	// ---- find best match -----
	bestMatchFull(iAlphaMin, alphaMin, iPsiMin, psiMin, dMin);
	invertSolution(iAlphaMin, iPsiMin, iAlphaMinInv, iPsiMinInv);
	// ---- fine search -----
	if (fineSearch)
	  // with fine search
	  fine(partialSearchAlgorithm, doubleSearchFine,
	       iAlphaMin, iPsiMin,
	       jAlphaOff, alphaMin,
	       jPsiOff, psiMin,
	       dMin,
	       fineMatch, fineSearchSurround);
	else
	  // without fine search
	  jAlphaOff = jPsiOff = 0;
    }

  };

} // namespace

#endif
